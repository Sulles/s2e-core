/**
 * @file attitude_with_cantilever_vibration.hpp
 * @brief Class to calculate spacecraft attitude with Runge-Kutta method
 */

#ifndef S2E_DYNAMICS_ATTITUDE_ATTITUDE_WITH_CANTILEVER_VIBRATION_HPP_
#define S2E_DYNAMICS_ATTITUDE_ATTITUDE_WITH_CANTILEVER_VIBRATION_HPP_

#include <math_physics/numerical_integration/numerical_integrator_manager.hpp>
#include <utilities/macros.hpp>

#include "attitude.hpp"
#include "ode_attitude_with_cantilever_vibration.hpp"

/**
 * @class AttitudeWithCantileverVibration
 * @brief Class to calculate spacecraft attitude with Runge-Kutta method
 */
class AttitudeWithCantileverVibration : public Attitude {
 public:
  /**
   * @fn AttitudeWithCantileverVibration
   * @brief Constructor
   * @param [in] angular_velocity_b_rad_s: Initial value of spacecraft angular velocity of the body fixed frame [rad/s]
   * @param [in] quaternion_i2b: Initial value of attitude quaternion from the inertial frame to the body fixed frame
   * @param [in] inertia_tensor_kgm2: Initial value of inertia tensor of the spacecraft [kg m^2]
   * @param [in] inertia_tensor_cantilever_kgm2: Initial value of inertia tensor of the cantilever [kg m^2]
   * @param [in] damping_ratio_cantilever: Initial value of damping ratio of the cantilever []
   * @param [in] intrinsic_angular_velocity_cantilever_rad_s: Initial value of intrinsic angular velocity [rad/s]
   * @param [in] torque_b_Nm: Initial torque acting on the spacecraft in the body fixed frame [Nm]
   * @param [in] propagation_step_s: Initial value of propagation step width [sec]
   * @param [in] simulation_object_name: Simulation object name for Monte-Carlo simulation
   */
  AttitudeWithCantileverVibration(const libra::Vector<3>& angular_velocity_b_rad_s, const libra::Quaternion& quaternion_i2b,
                                  const libra::Matrix<3, 3>& inertia_tensor_kgm2, const libra::Matrix<3, 3>& inertia_tensor_cantilever_kgm2,
                                  const double damping_ratio_cantilever, const double intrinsic_angular_velocity_cantilever_rad_s,
                                  const libra::Vector<3>& torque_b_Nm, const double propagation_step_s,
                                  const std::string& simulation_object_name = "attitude");
  /**
   * @fn ~AttitudeWithCantileverVibration
   * @brief Destructor
   */
  ~AttitudeWithCantileverVibration();

  /**
   * @fn Propagate
   * @brief Attitude propagation
   * @param [in] end_time_s: Propagation endtime [sec]
   */
  virtual void Propagate(const double end_time_s);

  // Override ILoggable
  /**
   * @fn GetLogHeader
   * @brief Override GetLogHeader function of ILoggable
   */
  virtual std::string GetLogHeader() const;
  /**
   * @fn GetLogValue
   * @brief Override GetLogValue function of ILoggable
   */
  virtual std::string GetLogValue() const;
  /**
   * @fn GetPreviousInertiaTensor_b_kgm2
   * @brief Return previous inertia tensor [kg m^2]
   */
  inline libra::Matrix<3, 3> GetPreviousInertiaTensor_b_kgm2() const { return previous_inertia_tensor_kgm2_; }
  /**
   * @fn GetTorqueInertiaTensor_b_Nm
   * @brief Return torque generated by inertia tensor [Nm]
   */
  inline libra::Vector<3> GetTorqueInertiaTensor_b_Nm() const { return torque_inertia_tensor_b_Nm_; }

  /**
   * @fn SetParameters
   * @brief Set parameters for Monte-Carlo simulation
   * @param [in] mc_simulator: Monte-Carlo simulation executor
   */
  virtual void SetParameters(const MonteCarloSimulationExecutor& mc_simulator);

  /**
   * @fn SetOdeParameters
   * @brief Set parameters for ordinary differential equations
   */
  void SetOdeParameters();

 private:
  double current_propagation_time_s_;                                 //!< current time [sec]
  libra::Matrix<3, 3> inverse_inertia_tensor_;                        //!< Inverse of inertia tensor
  libra::Matrix<3, 3> previous_inertia_tensor_kgm2_;                  //!< Previous inertia tensor [kgm2]
  libra::Vector<3> torque_inertia_tensor_b_Nm_;                       //!< Torque generated by inertia tensor [Nm]
  libra::Matrix<3, 3> inertia_tensor_cantilever_kgm2_;                //!< Inertia tensor of the cantilever [kgm2]
  libra::Matrix<3, 3> inverse_equivalent_inertia_tensor_cantilever_;  //!< Inverse of inertia tensor of the cantilever
  double attenuation_coefficient_;                                    //!< Attenuation coefficient
  double spring_coefficient_;                                         //!< Spring coefficient
  libra::Vector<3> angular_velocity_cantilever_rad_s_;                //!< Angular velocity of the cantilever with respect to the body frame [rad/s]
  libra::Vector<3> euler_angular_cantilever_rad_;                     //!< Euler angle of the cantilever with respect to the body frame [rad/s]

  libra::numerical_integration::AttitudeWithCantileverVibrationOde attitude_ode_;
  libra::numerical_integration::NumericalIntegratorManager<13> numerical_integrator_;

  /**
   * @fn SetStateFromPhysicalQuantities
   * @brief Set state for calculating the ordinary differential equation from physical quantities
   */
  libra::Vector<13> SetStateFromPhysicalQuantities();

  /**
   * @fn SetPhysicalQuantitiesFromState
   * @brief Set physical quantities from state acquired by calculation of the ordinary differential equation
   */
  void SetPhysicalQuantitiesFromState(libra::Vector<13> state);
};

#endif  // S2E_DYNAMICS_ATTITUDE_ATTITUDE_WITH_CANTILEVER_VIBRATION_HPP_
